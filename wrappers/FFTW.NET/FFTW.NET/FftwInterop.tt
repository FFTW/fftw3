<# /*
This file is part of FFTW.NET, a wrapper around the FFTW library
for the .NET framework.
Copyright (C) 2017 Tobias Meyer

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/ #>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
const string DllName32 = "libfftw3-3-x86";
const string DllName64 = "libfftw3-3-x64";
const string CallingConvention = "CallingConvention.Cdecl";

string[] Imports = {
	"bool;fftw_init_threads();[return: MarshalAs(UnmanagedType.Bool)]",
	"void;fftw_plan_with_nthreads(int nthreads)",
	"IntPtr;fftw_plan_dft(int rank, [MarshalAs(UnmanagedType.LPArray)] int[] n, IntPtr arrIn, IntPtr arrOut, DftDirection direction, PlannerFlags flags)",
	"IntPtr;fftw_plan_dft_r2c(int rank, [MarshalAs(UnmanagedType.LPArray)] int[] n, IntPtr arrIn, IntPtr arrOut, PlannerFlags flags)",
	"IntPtr;fftw_plan_dft_c2r(int rank, [MarshalAs(UnmanagedType.LPArray)] int[] n, IntPtr arrIn, IntPtr arrOut, PlannerFlags flags)",
	"void;fftw_destroy_plan(IntPtr plan)",
	"void;fftw_execute(IntPtr plan)",
	"bool;fftw_export_wisdom_to_filename([MarshalAs(UnmanagedType.LPStr)] string filename);[return: MarshalAs(UnmanagedType.Bool)]",
	"bool;fftw_import_wisdom_from_filename([MarshalAs(UnmanagedType.LPStr)] string filename);[return: MarshalAs(UnmanagedType.Bool)]",
	"bool;fftw_import_wisdom_from_string([MarshalAs(UnmanagedType.LPStr)] string wisdom);[return: MarshalAs(UnmanagedType.Bool)]",
	"void;fftw_export_wisdom([MarshalAs(UnmanagedType.FunctionPtr)] WriteCharHandler writeChar, IntPtr data)",
	"void;fftw_forget_wisdom()" };

// --------------------------------------------------------- Code End ----------------------------------------------------- #>
#region Copyright and License
/*
This file is part of FFTW.NET, a wrapper around the FFTW library
for the .NET framework.
Copyright (C) 2017 Tobias Meyer

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/
#endregion

// AUTOGENERATED FILE
// DO NOT MODIFY
using System;
using System.Runtime.InteropServices;

namespace FFTW.NET
{
	/// <summary>
	/// Provides access to FFTW C functions.
	/// For a documentation of this functions see
	/// http://www.fftw.org/fftw3_doc/index.html
	/// </summary>
	public static partial class FftwInterop
	{
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
foreach (string import in Imports)
{
	string[] parts = import.Split(';');
	string returnType = parts[0];
	int idxBracket = parts[1].IndexOf('(');
	string name = parts[1].Substring(0, idxBracket);
	string argumentList = parts[1].Substring(idxBracket);

	string args = string.Empty;
	foreach (var arg in argumentList.TrimStart('(').TrimEnd(')').Split(',').Select((x) => x.Split(' ').Last()))
		args += arg + ", ";
	if (!string.IsNullOrEmpty(args))
		args = args.Substring(0, args.Length - 2);

	string attributes = string.Empty;
	for (int i = 2; i < parts.Length; i++)
		attributes += Environment.NewLine+"\t\t" + parts[i];
// --------------------------------------------------------- Code End ----------------------------------------------------- #>

		#region <#=name#>

		[DllImport("<#=DllName32#>", CallingConvention = <#=CallingConvention#>, EntryPoint = "<#=name#>")]<#=attributes#>
		static extern <#=returnType#> <#=name#>_x86<#=argumentList#>;

		[DllImport("<#=DllName64#>", CallingConvention = <#=CallingConvention#>, EntryPoint = "<#=name#>")]<#=attributes#>
		static extern <#=returnType#> <#=name#>_x64<#=argumentList#>;

		public static <#=returnType#> <#=name#><#=argumentList#>
		{
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
	if (returnType == "void")
	{
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			if (Environment.Is64BitProcess)
				<#=name#>_x64(<#=args#>);
			else
				<#=name#>_x86(<#=args#>);
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
	}
	else
	{
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			if (Environment.Is64BitProcess)
				return <#=name#>_x64(<#=args#>);
			else
				return <#=name#>_x86(<#=args#>);
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
	}
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
		}

		#endregion
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
}
// --------------------------------------------------------- Code End ----------------------------------------------------- #>

	}
}